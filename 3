import numpy as np
import trimesh
import pyvista as pv
from scipy.ndimage import distance_transform_edt
from numba import njit
from tqdm import tqdm
import os

# --- 1. Numba 가속: 그리드 내 박스 확장 로직 ---
@njit
def grow_box_conservative(grid, start_z, start_y, start_x):
    d, h, w = grid.shape
    z1, z2 = start_z, start_z
    y1, y2 = start_y, start_y
    x1, x2 = start_x, start_x
    
    while True:
        expanded = False
        if x2 + 1 < w and np.all(grid[z1:z2+1, y1:y2+1, x2+1]):
            x2 += 1; expanded = True
        if x1 - 1 >= 0 and np.all(grid[z1:z2+1, y1:y2+1, x1-1]):
            x1 -= 1; expanded = True
        if y2 + 1 < h and np.all(grid[z1:z2+1, y2+1, x1:x2+1]):
            y2 += 1; expanded = True
        if y1 - 1 >= 0 and np.all(grid[z1:z2+1, y1-1, x1:x2+1]):
            y1 -= 1; expanded = True
        if z2 + 1 < d and np.all(grid[z2+1, y1:y2+1, x1:x2+1]):
            z2 += 1; expanded = True
        if z1 - 1 >= 0 and np.all(grid[z1-1, y1:y2+1, x1:x2+1]):
            z1 -= 1; expanded = True
        if not expanded: break
    return z1, z2, y1, y2, x1, x2

# --- 2. 커팅 보정 함수 ---
def refine_cutter_safely(mesh, center, size, steps=5):
    curr_size = np.array(size)
    for _ in range(steps):
        offsets = np.array([[0,0,0], [1,1,1], [1,1,-1], [1,-1,1], [1,-1,-1],
                            [-1,1,1], [-1,1,-1], [-1,-1,1], [-1,-1,-1],
                            [1,0,0], [-1,0,0], [0,1,0], [0,-1,0], [0,0,1], [0,0,-1]])
        pts = center + (offsets * curr_size * 0.5 * 0.98)
        if np.any(mesh.contains(pts)):
            curr_size *= 0.95 
        else:
            break
    return curr_size

# --- 3. 메인 프로세서 클래스 ---
class SubtractiveEngine:
    def __init__(self, mesh_path, resolution=60):
        if not os.path.exists(mesh_path):
            # 테스트용 샘플 생성
            mesh = trimesh.creation.annulus(r_min=10, r_max=25, height=12)
            mesh.export(mesh_path)
            
        self.mesh = trimesh.load(mesh_path)
        if not self.mesh.is_watertight:
            self.mesh.fill_holes()
            
        self.b_min, self.b_max = self.mesh.bounds
        self.base_center = (self.b_min + self.b_max) / 2
        self.base_size = self.b_max - self.b_min
        
        self.res = resolution
        self.pitch = np.max(self.base_size) / self.res
        self.origin = self.b_min
        self.cutters = []

    def run(self):
        dims = np.ceil(self.base_size / self.pitch).astype(int)
        grid = np.ones(dims[::-1], dtype=bool) 
        
        print(f"공간 분석 중... (해상도: {dims})")
        vox = self.mesh.voxelized(pitch=self.pitch)
        v_idx = ((vox.points - self.origin) / self.pitch).astype(int)
        
        # 안전 마진
        for dz in [-1, 0, 1]:
            for dy in [-1, 0, 1]:
                for dx in [-1, 0, 1]:
                    s_idx = v_idx + [dx, dy, dz]
                    vld = (s_idx[:,0]>=0) & (s_idx[:,0]<dims[0]) & \
                          (s_idx[:,1]>=0) & (s_idx[:,1]<dims[1]) & \
                          (s_idx[:,2]>=0) & (s_idx[:,2]<dims[2])
                    grid[s_idx[vld, 2], s_idx[vld, 1], s_idx[vld, 0]] = False

        temp_grid = grid.copy()
        with tqdm(desc="Processing Blocks") as pbar:
            while True:
                dist = distance_transform_edt(temp_grid)
                if dist.max() < 1.0: break
                
                seed = np.unravel_index(np.argmax(dist), temp_grid.shape)
                z1, z2, y1, y2, x1, x2 = grow_box_conservative(temp_grid, *seed)
                
                w_min = self.origin + np.array([x1, y1, z1]) * self.pitch
                w_max = self.origin + np.array([x2+1, y2+1, z2+1]) * self.pitch
                c = (w_min + w_max) / 2
                s = (w_max - w_min)
                
                safe_s = refine_cutter_safely(self.mesh, c, s)
                self.cutters.append({'center': c, 'size': safe_s})
                
                temp_grid[z1:z2+1, y1:y2+1, x1:x2+1] = False
                pbar.update(1)

    def visualize(self, mesh_path):
        p = pv.Plotter(shape=(1, 2), title="Subtractive Analysis")
        
        # 1. 원본 뷰
        p.subplot(0, 0)
        base_b = [self.b_min[0], self.b_max[0], self.b_min[1], self.b_max[1], self.b_min[2], self.b_max[2]]
        p.add_mesh(pv.Box(bounds=base_b), color='gray', style='wireframe', label="Base Stock")
        p.add_mesh(pv.read(mesh_path), color='white', opacity=0.3)

        # 2. 커터 뷰 (오류 수정 핵심 지점)
        p.subplot(0, 1)
        cutter_meshes = pv.MultiBlock()
        
        for i, d in enumerate(self.cutters):
            c, s = d['center'], d['size']
            b_cut = [c[0]-s[0]/2, c[0]+s[0]/2, c[1]-s[1]/2, c[1]+s[1]/2, c[2]-s[2]/2, c[2]+s[2]/2]
            box = pv.Box(bounds=b_cut)
            
            # [오류 해결] 각 블록 데이터에 ID 배열을 직접 추가합니다.
            # MultiBlock 전체에 배열을 던지는 대신, 내부 메쉬에 이름을 붙여 저장합니다.
            box.cell_data["CutterID"] = np.full(box.n_cells, i)
            cutter_meshes.append(box)
        
        # scalars 인자에 배열이 아닌 '배열의 이름(문자열)'을 전달합니다.
        p.add_mesh(cutter_meshes, scalars="CutterID", cmap='turbo', opacity=1.0, show_edges=True, show_scalar_bar=False)
        
        p.link_views()
        p.show()

if __name__ == "__main__":
    f_path = 'cushion_final.stl'
    engine = SubtractiveEngine(f_path, resolution=50) # 속도를 위해 해상도 조절
    engine.run()
    engine.visualize(f_path)

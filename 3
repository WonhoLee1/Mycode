import numpy as np
import trimesh
import pyvista as pv
from scipy.ndimage import distance_transform_edt
from numba import njit
from tqdm import tqdm
import os

# --- 1. 가속 확장 (초기 탐색용) ---
@njit
def grow_box_initial(grid, start_z, start_y, start_x):
    d, h, w = grid.shape
    z1, z2, y1, y2, x1, x2 = start_z, start_z, start_y, start_y, start_x, start_x
    while True:
        expanded = False
        if x2 + 1 < w and np.all(grid[z1:z2+1, y1:y2+1, x2+1]): x2 += 1; expanded = True
        if x1 - 1 >= 0 and np.all(grid[z1:z2+1, y1:y2+1, x1-1]): x1 -= 1; expanded = True
        if y2 + 1 < h and np.all(grid[z1:z2+1, y2+1, x1:x2+1]): y2 += 1; expanded = True
        if y1 - 1 >= 0 and np.all(grid[z1:z2+1, y1-1, x1:x2+1]): y1 -= 1; expanded = True
        if z2 + 1 < d and np.all(grid[z2+1, y1:y2+1, x1:x2+1]): z2 += 1; expanded = True
        if z1 - 1 >= 0 and np.all(grid[z1-1, y1:y2+1, x1:x2+1]): z1 -= 1; expanded = True
        if not expanded: break
    return z1, z2, y1, y2, x1, x2

# --- 2. 메인 엔진: 자유 육면체 피팅 ---
class FreeFormCutterEngine:
    def __init__(self, mesh_path, resolution=80, min_side=5.0, tolerance=0.1, opt_iters=3):
        self.mesh = trimesh.load(mesh_path)
        self.mesh.fix_normals()
        self.b_min, self.b_max = self.mesh.bounds
        self.base_size = self.b_max - self.b_min
        
        self.res = resolution
        self.min_side = min_side
        self.tol = tolerance # 침투 허용 오차 (mm)
        self.opt_iters = opt_iters # 면 정밀 피팅 반복 횟수
        
        self.pitch = np.max(self.base_size) / self.res
        self.origin = self.b_min
        self.cutters = []

    def refine_box_to_surface(self, bounds):
        """박스의 6개 면을 원본 메쉬 표면까지 자유롭게 확장"""
        refined = np.array(bounds).copy() # [xmin, xmax, ymin, ymax, zmin, zmax]
        
        for _ in range(self.opt_iters):
            # 6개 방향: -x, +x, -y, +y, -z, +z
            for i in range(6):
                axis = i // 2
                side = -1 if i % 2 == 0 else 1
                
                # 현재 면의 중심과 샘플 포인트들 생성
                center = [(refined[0]+refined[1])/2, (refined[2]+refined[3])/2, (refined[4]+refined[5])/2]
                center[axis] = refined[i]
                
                # 해당 면에서 메쉬까지의 거리 측정
                # 양수: 외부(공기), 음수: 내부(살)
                dist = trimesh.proximity.signed_distance(self.mesh, [center])[0]
                
                # 살을 파먹지 않는 선에서 면을 최대한 이동 (Tolerance 반영)
                # 공기 중에 있다면 더 확장, 살 안에 있다면 후퇴
                move_dist = -(dist + self.tol) * side
                refined[i] += move_dist
                
        return refined

    def run(self):
        # 1. 초기 복셀 그리드 생성
        dims = np.ceil(self.base_size / self.pitch).astype(int) + 2
        z, y, x = np.indices(dims[::-1])
        pts = np.stack([x.ravel(), y.ravel(), z.ravel()], axis=1) * self.pitch + self.origin
        inside = self.mesh.contains(pts)
        grid = (~inside).reshape(dims[::-1])
        
        temp_grid = grid.copy()
        skipping_mask = np.ones_like(temp_grid, dtype=bool)
        
        print(f"\n[자유 육면체 최적화 가동] Tolerance: {self.tol}mm")
        with tqdm(total=np.sum(grid), desc="Fitting Free Cuboids") as pbar:
            while True:
                search = temp_grid & skipping_mask
                dist_map = distance_transform_edt(search)
                if dist_map.max() < 0.5: break
                
                seed = np.unravel_index(np.argmax(dist_map), search.shape)
                z1, z2, y1, y2, x1, x2 = grow_box_initial(temp_grid, *seed)
                
                # 초기 복셀 기반 바운즈
                w_min = self.origin + np.array([x1, y1, z1]) * self.pitch
                w_max = self.origin + np.array([x2+1, y2+1, z2+1]) * self.pitch
                init_bounds = [w_min[0], w_max[0], w_min[1], w_max[1], w_min[2], w_max[2]]
                
                # [핵심] 면 자유 확장 (Floating Point Refinement)
                free_bounds = self.refine_box_to_surface(init_bounds)
                
                size = [free_bounds[1]-free_bounds[0], free_bounds[3]-free_bounds[2], free_bounds[5]-free_bounds[4]]
                
                if np.all(np.array(size) >= self.min_side):
                    self.cutters.append(free_bounds)
                    removed = np.sum(temp_grid[z1:z2+1, y1:y2+1, x1:x2+1])
                    temp_grid[z1:z2+1, y1:y2+1, x1:x2+1] = False
                    pbar.update(removed)
                else:
                    skipping_mask[seed] = False

    def visualize(self, mesh_path):
        p = pv.Plotter(shape=(1, 3))
        
        # 1. 원본
        p.subplot(0, 0); p.add_text("1. Original CAD"); p.add_mesh(self.mesh, color='white', opacity=0.5)
        
        # 2. 자유 육면체 커터
        p.subplot(0, 1); p.add_text(f"2. Free Cutters ({len(self.cutters)})")
        cutter_mb = pv.MultiBlock()
        for i, b in enumerate(self.cutters):
            box = pv.Box(bounds=b)
            box.cell_data["ID"] = np.full(box.n_cells, i)
            cutter_mb.append(box)
        p.add_mesh(cutter_mb, scalars="ID", cmap='turbo', show_edges=True, show_scalar_bar=False)

        # 3. 최종 가공 결과 (Boolean Subtraction 시뮬레이션)
        p.subplot(0, 2); p.add_text("3. Final Result")
        # 기본 블록 생성
        base_b = [self.b_min[0], self.b_max[0], self.b_min[1], self.b_max[1], self.b_min[2], self.b_max[2]]
        base_mesh = pv.Box(bounds=base_b).triangulate().subdivide(2)
        
        # 시각적 가공 결과 (커터 영역을 제외하고 렌더링)
        # 실제 불리언은 무거우므로 클리핑을 활용해 보여줍니다.
        p.add_mesh(base_mesh, color='lightgray', style='wireframe', opacity=0.2)
        p.add_mesh(self.mesh, color='lightgreen', label="Target Solid")
        
        p.link_views(); p.show()

# --- 실행 ---
if __name__ == "__main__":
    f_path = 'cushion_free.stl'
    if not os.path.exists(f_path):
        trimesh.creation.annulus(r_min=10, r_max=25, height=15).export(f_path)

    engine = FreeFormCutterEngine(
        mesh_path=f_path,
        resolution=60,       # 초기 탐색 해상도
        min_side=4.0,        # 최소 변 길이
        tolerance=0.05,      # 0.05mm까지 근접 허용 (매우 정밀)
        opt_level=3          # 최적화 강도
    )
    
    engine.run()
    engine.visualize(f_path)
